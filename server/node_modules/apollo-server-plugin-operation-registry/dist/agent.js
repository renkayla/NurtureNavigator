"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("./common");
const loglevel_1 = __importDefault(require("loglevel"));
const make_fetch_happen_1 = __importDefault(require("make-fetch-happen"));
const cache_1 = require("./cache");
const DEFAULT_POLL_SECONDS = 30;
const SYNC_WARN_TIME_SECONDS = 60;
const callToAction = `Ensure this server's schema has been published with 'apollo service:push' and that operations have been registered with 'apollo client:push'.`;
class Agent {
    constructor(options) {
        this.requestInFlight = null;
        this._timesChecked = 0;
        this.lastOperationSignatures = new Set();
        this.options = Object.create(null);
        this.fetchOptions = {
            timeout: this.pollSeconds() * 3 * 1000,
        };
        Object.assign(this.options, options);
        const { graphRef } = this.options.apollo;
        const at = graphRef.indexOf('@');
        if (at === -1) {
            this.graphId = graphRef;
            this.graphVariant = 'current';
        }
        else {
            this.graphId = graphRef.substring(0, at);
            this.graphVariant = graphRef.substring(at + 1);
        }
        this.logger = this.options.logger || loglevel_1.default.getLogger(common_1.pluginName);
        this.fetcher = this.options.fetcher || getDefaultGcsFetcher();
    }
    async requestPending() {
        return this.requestInFlight;
    }
    pollSeconds() {
        return this.options.pollSeconds || DEFAULT_POLL_SECONDS;
    }
    async start() {
        this.logger.debug('Starting operation registry agent...');
        const pulse = async () => await this.checkForUpdate();
        try {
            await pulse();
        }
        catch (err) {
            console.error('The operation manifest could not be fetched. Retries will continue, but requests will be forbidden until the manifest is fetched.', err.message || err);
        }
        this.timer =
            this.timer ||
                setInterval(function () {
                    pulse().catch((err) => console.error(err.message || err));
                }, this.pollSeconds() * 1000);
        this.timer.unref();
    }
    stop() {
        if (this.timer) {
            clearInterval(this.timer);
        }
    }
    timeSinceLastSuccessfulCheck() {
        if (!this.lastSuccessfulCheck) {
            return -Infinity;
        }
        return new Date().getTime() - this.lastSuccessfulCheck.getTime();
    }
    warnWhenLossOfSync() {
        if (this.timeSinceLastSuccessfulCheck() > SYNC_WARN_TIME_SECONDS * 1000) {
            console.warn(`WARNING: More than ${SYNC_WARN_TIME_SECONDS} seconds has elapsed since a successful fetch of the manifest. (Last success: ${this.lastSuccessfulCheck})`);
        }
    }
    async fetchAndUpdateStorageSecret() {
        const storageSecretUrl = (0, common_1.getStorageSecretUrl)(this.graphId, this.options.apollo.keyHash);
        const response = await this.fetcher(storageSecretUrl, this.fetchOptions);
        if (response.status === 304) {
            this.logger.debug('The storage secret was the same as the previous attempt.');
            return this.storageSecret;
        }
        if (!response.ok) {
            const responseText = await response.text();
            this.logger.debug(`Could not fetch storage secret ${responseText}`);
            return;
        }
        this.storageSecret = await response.json();
        return this.storageSecret;
    }
    async fetchManifest() {
        this.logger.debug(`Checking for storageSecret`);
        const storageSecret = await this.fetchAndUpdateStorageSecret();
        if (!storageSecret) {
            throw new Error('No storage secret found');
        }
        const storageSecretManifestUrl = (0, common_1.getOperationManifestUrl)(this.graphId, storageSecret, this.graphVariant);
        this.logger.debug(`Checking for manifest changes at ${storageSecretManifestUrl}`);
        const response = await this.fetcher(storageSecretManifestUrl, this.fetchOptions);
        if (response.status === 404 || response.status === 403) {
            throw new Error(`No manifest found for tag "${this.graphVariant}" at ` +
                `${storageSecretManifestUrl}. ${callToAction}`);
        }
        return response;
    }
    async tryUpdate() {
        this._timesChecked++;
        let response;
        try {
            response = await this.fetchManifest();
            if (response.status === 304) {
                return false;
            }
            if (!response.ok) {
                const responseText = await response.text();
                if (responseText.includes('<Code>AccessDenied</Code>')) {
                    throw new Error(`No manifest found. ${callToAction}`);
                }
                throw new Error(`Unexpected status: ${responseText}`);
            }
            const contentType = response.headers.get('content-type');
            if (contentType && contentType !== 'application/json') {
                throw new Error(`Unexpected 'Content-Type' header: ${contentType}`);
            }
        }
        catch (err) {
            const ourErrorPrefix = `Unable to fetch operation manifest for graph ID '${this.graphId}': ${err}`;
            err.message = `${ourErrorPrefix}: ${err}`;
            throw err;
        }
        await this.updateManifest(await response.json());
        return true;
    }
    async checkForUpdate() {
        this.warnWhenLossOfSync();
        if (this.requestInFlight) {
            return this.requestInFlight;
        }
        this.requestInFlight = this.tryUpdate();
        const resetRequestInFlight = () => (this.requestInFlight = null);
        return this.requestInFlight
            .then((result) => {
            this.lastSuccessfulCheck = new Date();
            resetRequestInFlight();
            return result;
        })
            .catch((err) => {
            resetRequestInFlight();
            throw err;
        });
    }
    async updateManifest(manifest) {
        if (!manifest ||
            manifest.version !== 2 ||
            !Array.isArray(manifest.operations)) {
            throw new Error('Invalid manifest format.');
        }
        const incomingOperations = new Map();
        const replacementSignatures = new Set();
        for (const { signature, document } of manifest.operations) {
            incomingOperations.set(signature, document);
            replacementSignatures.add(signature);
            if (!this.lastOperationSignatures.has(signature)) {
                this.logger.debug(`Incoming manifest ADDs: ${signature}`);
                this.options.store.set((0, common_1.getStoreKey)(signature), document);
            }
        }
        for (const signature of this.lastOperationSignatures) {
            if (!incomingOperations.has(signature)) {
                this.logger.debug(`Incoming manifest REMOVEs: ${signature}`);
                this.options.store.delete((0, common_1.getStoreKey)(signature));
            }
        }
        this.lastOperationSignatures = replacementSignatures;
    }
}
exports.default = Agent;
const GCS_RETRY_COUNT = 5;
function getDefaultGcsFetcher() {
    return make_fetch_happen_1.default.defaults({
        cacheManager: new cache_1.HttpRequestCache(),
        headers: {
            'user-agent': [
                require('../package.json').name,
                require('../package.json').version,
            ].join('/'),
        },
        retry: {
            retries: GCS_RETRY_COUNT,
            factor: 2,
            minTimeout: 1000,
            randomize: true,
        },
    });
}
//# sourceMappingURL=agent.js.map